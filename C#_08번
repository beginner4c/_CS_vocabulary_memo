ToString()

Object 클래스

inheritance 상속
 - 기존에 구현한 클래스의 데이터멤버와 멤버 함수를 물려 받아 새로운 클래스를 구현하는 제도(복사 방지)

사람 -> 포유류 -> 동물 -> 생물 -> 사물
코끼리 -> 포유류 -> 동물 -> 생물 -> 사물
뱀 -> 포유류 -> 동물 -> 생물 -> 사물
사과 -> 식물 -> 과일 -> 생물 -> 사물

ToString()

Object 클래스
// Object 클래스 내부의 함수들을 사용해봄
// ToString의 경우 override를 통해 주로 사용한다
// ReferenceEquals는 주어진 parameter들의 주소값을 비교한다
// MemberwiseClone은 멤버값은 같지만 주소값들이 다른 걸 복사한다 (단, access modifier가 protected이기 때문에 상속받은 클래스 내부에서만 사용 가능하다)
// GetType 함수는 type을 확인할 때 사용한다
// Equals 함수는 기본적으로 reference를 비교할 때 사용하는 함수지만 override해서 사용을 많이 한다
 - 자바에도 거의 똑같이 구현되어 있다 (사실 자바가 먼저다)

inheritance 상속
 - 기존에 구현한 클래스의 데이터멤버와 멤버 함수를 물려 받아 새로운 클래스를 구현하는 제도(복사 방지)
 - 모든 클래스는 Object 클래스를 default로 상속하고 있다

override 재정의
 - 상속받은 클래스에서 부모 클래스의 함수를 사용자가 재정의하는 것

사람 -> 포유류 -> 동물 -> 생물 -> 사물
코끼리 -> 포유류 -> 동물 -> 생물 -> 사물
뱀 -> 포유류 -> 동물 -> 생물 -> 사물
사과 -> 식물 -> 과일 -> 생물 -> 사물
자동차 -> 탈것 -> 공산품 -> 무생물 -> 사물
TV -> 가전품 -> 공산품 -> 무생물 -> 사물

bitwise operator

& | ^ ~ << >>


x y      & | ^
0 0     0 0 0
0 1     0 1 1 
1 0     0 1 1
1 1     1 1 0

1010 1100
x >> 2 => 001010 1100 -> 0010 1011 이런 식으로 계산된다

목적 : true/flase 상태값 저장 시에 기억장소 절약

bool - 1byte 크기의 자료형

잘생겼나?    키 큰가?       부자인가?      성별은?
true	    true	         false	   false
0000 0001 / 0000 0001  / 0000 0000   / 0000 0000
 - 이런식으로 boolean은 1 혹은 0인데 나머지 bit가 버려지는 게 아까워서 bitwise operator 사용 

bitwise로 한번에 표현할 때
     3210 - 비트의 위치 (잘생, 키큰, 부자, 성별)
x = 1100 - true false의 내용 (잘생겼고 키가 크고 부자 아니고 성별이 여자)
     1101 - 수정할 때 (잘생겼고 키가 크고 부자 아니고 성별이 남자)

1. read 연산
if (x & (1 << n)) {
  // true (둘 중 하나만 0 이면 0이 되는 연산)
} else {
  // false 
}

2. write 연산
 - 1을 write 하는 경우 (둘 중 하나라도 1이면 1인 연산)
x = x | (1 << n);

       3210
x =   ????

0000 0100
????  ?1??

3. write 연산 
 - 0을 write 하는 경우 (둘 중 하나라도 0이면 0)
x = x & ~(1 << n);

       3210
x =   ????

1111 1011
????  ?0??

특이하게 사용하는 ^ exclusive or 배타적 논리합 연산

swap을 해 줄 경우
 - 일반적 연산에서는 tmp를 사용한다
 - exclusive or 연산을 사용하면 메모리의 사용을 줄이고 빠른 연산 결과를 본다
 ex) x = x ^ y
     y = x ^ y
     x = x ^ y
